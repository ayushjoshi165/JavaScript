Javascript function can be passes to another functions and can be used as a variable.
Example : 
function log(a) {
  a();
}

log(function passingfunction(){
console.log("Passing function ran");
});
// output is Passing function ran

-------------------------------------------------

Pass by value - it works for primitives when a has value 3 and then b is passes as paramenter it will reference to the same value but a copy adresses are not same 

Pass by reference - it works in objects and function (special type of objects in javascript) if we set the values of references eqaulr it will point to the exact asmae memory location.


// by value

var a = 3;

var b;

b = a; // creates a new spot in memory and copy the value
a = 2; // now both variables are on their own
console.log(a);
console.log(b);

// by referance (all objects (including functions ))

var c = { greeting: "hi" };

var d;

d = c;

c.greeting = "hello"; // mutated

console.log(d);
console.log(c);

// here both values are same unlike the above example as they both are referencing to the same memory location 


// lests pass it in function as objects

function changeGreetings(obj) {
  obj.greeting = "hola!";
}
changeGreetings(c);
console.log(d);
console.log(c);

*********************// equal operator sets a new memory location (new address) ****************

c = { greeting: "Howdy" };

console.log(d);
console.log(c);

// output wont cahnge both the objects as it is set to different memory location

//All primitive types are by value, and all objects are by reference.

------------------------------------------------------------------------------

Objects ,Functions and 'this'

when a function is invoked a new execution context is created.

Remember not to confuse this with the object that we've been discussing.

The object sitting in memory that is a function has properties and methods.

It has a name property and a code property where the code lives.

But when that code is invoked and

execution context is created and put on the execution stack.

And that determines how that code is Run, is executed.

So think of the execution context

as focusing on that code portion of that function object.

What happens when I run the code in that code property?

----------------------------------
And we also know that in JavaScript engine every time

an execution context is created, that is every time a function is Run.

It gives us, without us having to create it, declare it or

anything, it gives us this variable called this, which can be useful.

And this will be pointing at a different object,
------------------------------------------------------

var c = {
  name: "this is c object",
  log: function () {
    this.name = "updated c object";
    console.log(this);

    var setname = function (newname) {
      this.name = newname;
    };
    setname("Updated again c object !"); // here we thought that we will see updated again output
    // but we will see updated c object in output because even if this propery is inside
    // out object function still while this inner function goes in execution context it will attach the
    // name to global object which we can see in console so to fix this we will take a seperate variable inside
    // and as it is object it is pass by refernce so the new variable will point to the same this
    // therefore we will replace this inside the function with that varaible name
    console.log(this);
  },
};
console.log("test");
c.log();
console.log("---------------------------------------------");
var d = {
  name: "this is d object",
  log: function () {
    var self = this;
    self.name = "updated d object";
    console.log(self);

    var setname = function (newname) {
      self.name = newname;
    };
    setname("Updated again d object !"); // here we thought that we will see updated again output
    // but we will see updated c object in output because even if this propery is inside
    // out object function still while this inner function goes in execution context it will attach the
    // name to global object which we can see in console so to fix this we will take a seperate variable inside
    // and as it is object it is pass by refernce so the new variable will point to the same this
    // therefore we will replace this inside the function with that varaible name
    console.log(self);
  },
};

d.log();

// now this will reference to the current object instead appending the value in global object 
// for the inner function 

-------------------------------------------------------

